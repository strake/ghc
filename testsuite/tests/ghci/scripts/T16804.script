let custom c s e = let cmd = c ++ " " ++ s ++ maybe "" (" " ++) e; in (putStrLn ("input: " ++ cmd) >> return cmd)

let tp s = custom ":type-at" s (Just "undefined")
let up s = custom ":uses" s Nothing
let cp s = putStrLn s >> return ""

let ruler p n = putStrLn $ replicate p ' ' ++ replicate (n * 10) ' ' ++ "1234567890"
let putruler p s = ruler p 0 >> ruler p 1 >> ruler p 2 >> ruler p 3 >> return ""

:def tp tp
:def up up
:def cp cp
:def putruler1 (putruler 2)
:def putruler2 (putruler 3)

:set +c
:l T16804a.hs T16804b.hs

:cp  1 module T16804 where
:putruler1

:tp T16804a.hs  1  8  1 15
:up T16804a.hs  1  8  1 15

:cp  2 
:cp  3 import Data.Monoid
:putruler1

:tp T16804a.hs  3  8  3 12
:tp T16804a.hs  3  8  3 19

:up T16804a.hs  3  8  3 12
:up T16804a.hs  3  8  3 19

:cp  4 
:cp  5 data Test = A | B
:cp  6   deriving (Show)
:putruler1

:tp T16804a.hs  5  6  5 10
:tp T16804a.hs  5 13  5 14
:tp T16804a.hs  5 15  5 16
:tp T16804a.hs  5 17  5 18
:tp T16804a.hs  6 13  6 17

:up T16804a.hs  5  6  5 10
:up T16804a.hs  5 13  5 14
:up T16804a.hs  5 15  5 16
:up T16804a.hs  5 17  5 18
:up T16804a.hs  6 13  6 17

:cp  7 instance Monoid Test where
:cp  8   mempty = A
:cp  9   -- gone 
:cp 10   -- gone
:putruler1
:tp T16804a.hs  7 10  7 16 
:tp T16804a.hs  7 17  7 21
:tp T16804a.hs  7 10  7 21
:tp T16804a.hs  8  3  8  9
:tp T16804a.hs  8 12  8 13

:up T16804a.hs  7 10  7 16 
:up T16804a.hs  7 17  7 21
:up T16804a.hs  7 10  7 21
:up T16804a.hs  8  3  8  9
:up T16804a.hs  8 12  8 13

:cp 11  
:cp 12 testFunction :: Test -> Test -> Bool
:cp 13 testFunction A B = True
:cp 14 testFunction B A = True
:cp 15 testFunction _ _ = False
:putruler2
:tp T16804a.hs 12  1 12 13
:tp T16804a.hs 13  1 13 13
:tp T16804a.hs 13 14 13 15
:tp T16804a.hs 13 16 13 17
:tp T16804a.hs 15 16 15 17
:tp T16804a.hs 15 20 15 25

:up T16804a.hs 12  1 12 13
:up T16804a.hs 13  1 13 13
:up T16804a.hs 13 14 13 15
:up T16804a.hs 13 16 13 17
:up T16804a.hs 15 16 15 17
:up T16804a.hs 15 20 15 25

:cp 
:cp 16  
:cp 17 testFunction2 :: Bool -> Test
:cp 18 testFunction2 True = A
:cp 19 testFunction2 False = B
:putruler2
:tp T16804a.hs 18 15 18 19
:tp T16804a.hs 18 22 18 23

:up T16804a.hs 18 15 18 19
:up T16804a.hs 18 22 18 23

:cp 20  
:cp 21 niceValue :: Int
:cp 22 niceValue = getSum (Sum 1 <> Sum 2 <> mempty)
:putruler2
:tp T16804a.hs 22 13 22 19
:tp T16804a.hs 22 21 22 24
:tp T16804a.hs 22 25 22 26
:tp T16804a.hs 22 21 22 26
:tp T16804a.hs 22 27 22 29

:up T16804a.hs 22 13 22 19
:up T16804a.hs 22 21 22 24
:up T16804a.hs 22 25 22 26
:up T16804a.hs 22 21 22 26
:up T16804a.hs 22 27 22 29

:cp 23  
:cp 24 niceValue2 :: Test
:cp 25 niceValue2 = A <> A <> A <> B <> A <> mempty
:putruler2
:tp T16804a.hs 25 14 25 15
:tp T16804a.hs 25 16 25 18
:tp T16804a.hs 25 39 25 45

:up T16804a.hs 25 14 25 15
:up T16804a.hs 25 16 25 18
:up T16804a.hs 25 39 25 45

:cp 26
:cp 27 instance Semigroup Test where
:cp 28   A <> val = val
:cp 29   B <> _   = B
:putruler2
:tp T16804a.hs 28  3 28  4
:tp T16804a.hs 28  5 28  7
:tp T16804a.hs 28  8 28 11
:tp T16804a.hs 28 14 28 17
:tp T16804a.hs 29  3 29  4
:tp T16804a.hs 29  5 29  7
:tp T16804a.hs 29  8 29  9
:tp T16804a.hs 29 14 29 15

:up T16804a.hs 28  3 28  4
:up T16804a.hs 28  5 28  7
:up T16804a.hs 28  8 28 11
:up T16804a.hs 28 14 28 17
:up T16804a.hs 29  3 29  4
:up T16804a.hs 29  5 29  7
:up T16804a.hs 29  8 29  9
:up T16804a.hs 29 14 29 15
