
RolesIArray.hs:10:13:
    Could not coerce from ‘UArray i Word64’ to ‘UArray i N’
      because the second type argument of ‘UArray’ has role Nominal,
      but the arguments ‘Word64’ and ‘N’ differ
      arising from the coercion of the method ‘Data.Array.Base.unsafeAccumArray’
        from type ‘forall e' i.
                   Ix i =>
                   (Word64 -> e' -> Word64)
                   -> Word64 -> (i, i) -> [(Int, e')] -> UArray i Word64’
          to type ‘forall e' i.
                   Ix i =>
                   (N -> e' -> N) -> N -> (i, i) -> [(Int, e')] -> UArray i N’
    Possible fix:
      use a standalone 'deriving instance' declaration,
        so you can specify the instance context yourself
    When deriving the instance for (IArray UArray N)

RolesIArray.hs:10:13:
    Could not coerce from ‘UArray i Word64’ to ‘UArray i N’
      because the second type argument of ‘UArray’ has role Nominal,
      but the arguments ‘Word64’ and ‘N’ differ
      arising from the coercion of the method ‘Data.Array.Base.unsafeAccum’
        from type ‘forall e' i.
                   Ix i =>
                   (Word64 -> e' -> Word64)
                   -> UArray i Word64 -> [(Int, e')] -> UArray i Word64’
          to type ‘forall e' i.
                   Ix i =>
                   (N -> e' -> N) -> UArray i N -> [(Int, e')] -> UArray i N’
    Possible fix:
      use a standalone 'deriving instance' declaration,
        so you can specify the instance context yourself
    When deriving the instance for (IArray UArray N)

RolesIArray.hs:10:13:
    Could not coerce from ‘UArray i Word64’ to ‘UArray i N’
      because the second type argument of ‘UArray’ has role Nominal,
      but the arguments ‘Word64’ and ‘N’ differ
      arising from the coercion of the method ‘Data.Array.Base.unsafeReplace’
        from type ‘forall i.
                   Ix i =>
                   UArray i Word64 -> [(Int, Word64)] -> UArray i Word64’
          to type ‘forall i.
                   Ix i =>
                   UArray i N -> [(Int, N)] -> UArray i N’
    Possible fix:
      use a standalone 'deriving instance' declaration,
        so you can specify the instance context yourself
    When deriving the instance for (IArray UArray N)

RolesIArray.hs:10:13:
    Could not coerce from ‘UArray i Word64’ to ‘UArray i N’
      because the second type argument of ‘UArray’ has role Nominal,
      but the arguments ‘Word64’ and ‘N’ differ
      arising from the coercion of the method ‘Data.Array.Base.unsafeAt’
        from type ‘forall i. Ix i => UArray i Word64 -> Int -> Word64’
          to type ‘forall i. Ix i => UArray i N -> Int -> N’
    Possible fix:
      use a standalone 'deriving instance' declaration,
        so you can specify the instance context yourself
    When deriving the instance for (IArray UArray N)

RolesIArray.hs:10:13:
    Could not coerce from ‘UArray i Word64’ to ‘UArray i N’
      because the second type argument of ‘UArray’ has role Nominal,
      but the arguments ‘Word64’ and ‘N’ differ
      arising from the coercion of the method ‘Data.Array.Base.unsafeArray’
        from type ‘forall i.
                   Ix i =>
                   (i, i) -> [(Int, Word64)] -> UArray i Word64’
          to type ‘forall i. Ix i => (i, i) -> [(Int, N)] -> UArray i N’
    Possible fix:
      use a standalone 'deriving instance' declaration,
        so you can specify the instance context yourself
    When deriving the instance for (IArray UArray N)

RolesIArray.hs:10:13:
    Could not coerce from ‘UArray i Word64’ to ‘UArray i N’
      because the second type argument of ‘UArray’ has role Nominal,
      but the arguments ‘Word64’ and ‘N’ differ
      arising from the coercion of the method ‘Data.Array.Base.numElements’
        from type ‘forall i. Ix i => UArray i Word64 -> Int’
          to type ‘forall i. Ix i => UArray i N -> Int’
    Possible fix:
      use a standalone 'deriving instance' declaration,
        so you can specify the instance context yourself
    When deriving the instance for (IArray UArray N)

RolesIArray.hs:10:13:
    Could not coerce from ‘UArray i Word64’ to ‘UArray i N’
      because the second type argument of ‘UArray’ has role Nominal,
      but the arguments ‘Word64’ and ‘N’ differ
      arising from the coercion of the method ‘bounds’
        from type ‘forall i. Ix i => UArray i Word64 -> (i, i)’
          to type ‘forall i. Ix i => UArray i N -> (i, i)’
    Possible fix:
      use a standalone 'deriving instance' declaration,
        so you can specify the instance context yourself
    When deriving the instance for (IArray UArray N)
