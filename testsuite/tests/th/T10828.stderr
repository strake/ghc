data family D_0 a_1 :: * -> *
data instance D_0 GHC.Types.Int GHC.Types.Bool :: * where
    DInt_2 :: D_0 GHC.Types.Int GHC.Types.Bool
data E_3 where MkE_4 :: forall a_5 . a_5 -> E_3
data Foo_6 a_7 b_8 where
    MkFoo_9, MkFoo'_10 :: forall a_11 b_12 . a_11 -> Foo_6 a_11 b_12
newtype Bar_13 :: * -> GHC.Types.Bool -> *
  = MkBar_14 :: forall a_15 b_16 . a_15 -> Bar_13 a_15 b_16
data T10828.T (a_0 :: *) where
    T10828.MkT :: forall (a_1 :: *) . a_1 -> a_1 -> T10828.T a_1
    T10828.MkC :: forall (a_2 :: *) (b_3 :: *) . Data.Type.Equality.~ a_2
                                                                       GHC.Types.Int => {T10828.foo :: a_2,
                                                                                         T10828.bar :: b_3} -> T10828.T GHC.Types.Int
data T'_0 a_1 :: * where
    MkT'_2 :: forall a_3 . a_3 -> a_3 -> T'_0 a_3
    MkC'_4 :: forall a_5 b_6 . a_5 ~ GHC.Types.Int => {foo_7 :: a_5,
                                                       bar_8 :: b_6} -> T'_0 GHC.Types.Int
TYPE SIGNATURES
TYPE CONSTRUCTORS
  type role Bar representational phantom
  newtype Bar a (b :: Bool) where
    MkBar :: a -> Bar a b
    Kind: GHC.Types.Type -> Bool -> GHC.Types.Type
  data family D a0 b
  data E where
    MkE :: a0 -> E
    Kind: *
  type role Foo representational phantom
  data Foo a0 b0 where
    MkFoo :: a0 -> Foo a0 b0
    MkFoo' :: a0 -> Foo a0 b0
    Kind: * -> * -> *
  type role T nominal
  data T a where
    MkT :: a -> a -> T a
    MkC :: a1 ~ Int => {foo :: a1, bar :: b} -> T Int
    Kind: * -> GHC.Types.Type
COERCION AXIOMS
  axiom T10828.NTCo:Bar :: Bar a b = a -- Defined at T10828.hs:9:4
  axiom T10828.TFCo:R:DIntBool ::
    D Int Bool = T10828.R:DIntBool -- Defined at T10828.hs:9:4
FAMILY INSTANCES
  data instance D Int Bool
Dependent modules: []
Dependent packages: [array-<VERSION>, base-<VERSION>, binary-<VERSION>,
                     bytestring-<VERSION>, containers-<VERSION>, deepseq-<VERSION>,
                     ghc-boot-<VERSION>, ghc-prim-<VERSION>, integer-<IMPL>-<VERSION>,
                     pretty-<VERSION>, template-haskell-<VERSION>]

==================== Typechecker ====================
foo = ()
bar = ()
T10828.$tcT
  = GHC.Types.TyCon 0## 0## T10828.$trModule
      (GHC.Types.TrNameS "T"#)
T10828.$tc'MkT
  = GHC.Types.TyCon
      0## 0## T10828.$trModule
      (GHC.Types.TrNameS "'MkT"#)
T10828.$tc'MkC
  = GHC.Types.TyCon
      0## 0## T10828.$trModule
      (GHC.Types.TrNameS "'MkC"#)
T10828.$tc'DInt
  = GHC.Types.TyCon
      0## 0## T10828.$trModule
      (GHC.Types.TrNameS "'DInt"#)
T10828.$tcBar
  = GHC.Types.TyCon
      0## 0## T10828.$trModule
      (GHC.Types.TrNameS "Bar"#)
T10828.$tc'MkBar
  = GHC.Types.TyCon
      0## 0## T10828.$trModule
      (GHC.Types.TrNameS "'MkBar"#)
T10828.$tcFoo
  = GHC.Types.TyCon
      0## 0## T10828.$trModule
      (GHC.Types.TrNameS "Foo"#)
T10828.$tc'MkFoo
  = GHC.Types.TyCon
      0## 0## T10828.$trModule
      (GHC.Types.TrNameS "'MkFoo"#)
T10828.$tc'MkFoo'
  = GHC.Types.TyCon
      0## 0## T10828.$trModule
      (GHC.Types.TrNameS "'MkFoo'"#)
T10828.$tcE
  = GHC.Types.TyCon 0## 0## T10828.$trModule
      (GHC.Types.TrNameS "E"#)
T10828.$tc'MkE
  = GHC.Types.TyCon
      0## 0## T10828.$trModule
      (GHC.Types.TrNameS "'MkE"#)
T10828.$tcD
  = GHC.Types.TyCon 0## 0## T10828.$trModule
      (GHC.Types.TrNameS "D"#)
T10828.$trModule
  = GHC.Types.Module
      (GHC.Types.TrNameS "main"#) (GHC.Types.TrNameS "T10828"#)
