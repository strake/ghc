\documentclass{article}

\usepackage{mdframed}
\usepackage{pifont}
\usepackage{graphicx} %[pdftex] OR [dvips]
\usepackage{fullpage}
\usepackage{wrapfig}
\usepackage{float}
\usepackage{titling}
\usepackage{hyperref}
\usepackage{tikz}
\usepackage{color}
\usepackage{footnote}
\usepackage{float}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{bigfoot}
\usepackage{amssymb}

\newenvironment{aside}
  {\begin{mdframed}[style=0,%
      leftline=false,rightline=false,leftmargin=2em,rightmargin=2em,%
          innerleftmargin=0pt,innerrightmargin=0pt,linewidth=0.75pt,%
      skipabove=7pt,skipbelow=7pt]\small}
  {\end{mdframed}}

\setlength{\droptitle}{-6em}

\newcommand{\Red}[1]{{\color{red} #1}}

\title{Backpack shaping by example}

\begin{document}

\maketitle

Note: this document assumes familiarity with the syntax of Backpack. Go
read the Backpack Manual (\url{http://web.mit.edu/~ezyang/Public/backpack-manual.pdf}) if you haven't already.

\begin{aside}
\textbf{Guru meditation.} These asides contain more complex examples
which justify certain design choices. They can be skipped without missing
out on important information.  You might have to have read further to
understand them.
\end{aside}

\section{What is shaping?}

When you write an ordinary Haskell package, if you define
the data type \verb|ByteString| in \verb|Data.ByteString.Lazy|,
and define it again in \verb|Data.ByteString.Strict|, you
do not expect these types to be the same.

However, if you are doing modular programming with module interfaces, you
might want to define a type in a module interface, but not say where
it comes from: that's the job of whoever implements the
interface.  \verb|ByteString| defined in two interfaces could be
the same\ldots or they might be different.  Shaping tells you whether
or not they are the same.

Imagine you have two signature packages: \verb|haskell98-base-sigs|,
which just exports \verb|Prelude| defining \verb|Int|; and \verb|ghc-base-sigs|,
which provides a more internal version of \verb|Int| in \verb|GHC.Base|, with
\verb|Prelude| simply reexporting the definition there.

\begin{verbatim}
package haskell98-base-sigs (Prelude) where
    signature Prelude(Int) where
        data Int

package ghc-base-sigs (Prelude, GHC.Base) where
    include ghc-prim
    signature GHC.Base(Int(..)) where
        import GHC.Prim(Int#)
        data Int = I# Int#
    signature Prelude(Int) where
        import GHC.Base
\end{verbatim}

Now, suppose you want to type-check a package which is using both
signatures at the same time:

\begin{verbatim}
package p (A) where
    include haskell98-base-sigs
    include ghc-base-sigs
    module A where
        import Prelude
        import GHC.Base
        ... Int ...
\end{verbatim}

There are two places where \verb|Int| is defined, and we ought not to
accept \verb|A| unless \verb|haskell98-base-sigs:Prelude.Int| and
\verb|ghc-base-sigs:GHC.Base.Int| are the same.  In fact, they are the
same;\footnote{The reason is \verb|p| \emph{linked} the two \verb|Prelude|s
together: they must be implemented with the same module.  Since any
implementation of \verb|Prelude| can only define one entity named
\verb|Int|, we can infer that the separate \verb|Int|s in the signatures
must be the same; and by inference, that
\verb|ghc-base-sigs:GHC.Base.Int| is equivalent as well.} however, if you
remove module \verb|ghc-base-sigs:Prelude|, the two \verb|Int|s are no longer
equal!

Shaping is the process responsible for concluding that these two types are
equal.  By the end of this document, you should understand how and why \verb|Int|
is type equal in the previous example, as well as understand other examples.

\section{Defining pre-shape}

Informally, a package consists of a collection of modules and
signatures, which, given some \emph{required} holes at some module
names, can \emph{provide} some modules (at some other module names) for
import by anyone who includes the package.  The requires and provides
of a package can be written explicitly in the header of a package:

\begin{verbatim}
pkgexports ::= { ModName } "requires" { ModName }
\end{verbatim}

Here are the explicit headers of the packages in the introductory example:

\begin{verbatim}
package haskell98-base-sigs (Prelude)           requires (Prelude)
package ghc-base-sigs       (Prelude, GHC.Base) requires (Prelude, GHC.Base)
package p                   (A)                 requires (Prelude, GHC.Base)
\end{verbatim}

When you instantiate a package, an instance is identified by a \emph{package key},
which what module each hole was instantiated with (or the module is put
in a special \verb|HOLE| package if it was not instantiated at all, as you
might when type-checking a package which still has holes in it):

\begin{verbatim}
PkgKey  ::= SrcPkgId "(" { ModName "->" Module } ")"
          | HOLE
\end{verbatim}

A module might get instantiated multiple times (when its package is instantiated
multiple times): a particular instance of a module is identified by the
its enclosing package key plus its module name:

\begin{verbatim}
Module  ::= PkgKey ":" ModName
\end{verbatim}

To infer the provides and requires of a package, however, 

The full pre-shape of a package, however, also specifies the module identities
of everything it exports:

\begin{verbatim}
preshape ::= { ModName "->" Module } "requires" { ModName "->" Module }
\end{verbatim}

\begin{verbatim}
haskell98-base-sigs
    provides: Prelude  -> HOLE:Prelude

ghc-base-sigs
    provides: Prelude  -> HOLE:Prelude
              GHC.Base -> HOLE:GHC.Base
p
    provides: A        -> p(Prelude  -> HOLE:Prelude,
                            GHC.Base -> HOLE:GHC.Base):A
\end{verbatim}


Depending on how we vary how the requirements of a package are filled,
the types and values defined in the package may be different.  So a
mapping of required hole names to proper modules uniquely defines an
instance of the package: we identify these instances with \emph{package
keys} (\verb|PkgKey|).



An example package key would be \verb|prelude-sig(Prelude -> base():Prelude)|,
where \verb|prelude-sig| has a single requirement that was filled by the
\verb|Module| \verb|base():Prelude|.

\section{Defining shape}


A \emph{shape} adds more information about the declarations that the
module exports.  Nothing as fancy as a full type; just a \verb|Name|
which identifies the name in question.  We'll say more about what
\verb|Name|s are shortly, but the important property is that if two
\verb|Name|s of two types are the same, they are type-equal (value-equal
in the case of values).  We can thus define a shape as a mapping of
module name to the set of \verb|Name|s it provides and the set of
\verb|Name|s it requires.

\begin{verbatim}
Shape ::=
    "provided:" { ModName "->" { Name } }
    "required:" { ModName "->" { Name } }
\end{verbatim}

We should say a little bit about \verb|Name|s.  This terminology
comes from the internals of GHC, where it is very useful to have a
representation of identity that distinguishes a type from anything else.
In old versions of GHC, a \verb|Name| was the source package ID (\verb|bytestring-0.1|)
plus the module name it was defined in (\verb|Data.ByteString.Lazy|)
plus the actual name of the type (\verb|ByteString|).  As a simplifying assumption
in this document, we'll assume version numbers don't exist, but technically
everywhere there is a package name in this document, there should also be
a version number.

In Backpack, this is \emph{still} not enough: we must also record
the mapping from each required module name to the actual \verb|Module| which
is fulfilling that requirement. Thus, the full specification of \verb|Name|
(omitting version numbers) is:

\begin{verbatim}
Name    ::= Module "." OccName
OccName ::= -- a plain old name, e.g. undefined, Bool, Int
\end{verbatim}

\newpage

\begin{aside}
\textbf{Mini-guru meditation.}  Why do we need the mapping of holes to modules? Consider:
\begin{verbatim}
package p (A) requires (H) where
    signature H(T) where
        data T
    module A(A) where
        import H
        data A = A T
package q (A1, A2) where
    module H1(T) where
        data T = T Int
    module H2(T) where
        data T = T Bool
    include p (A as A1) requires (H as H1)
    include p (A as A2) requires (H as H2)
\end{verbatim}

If we conclude that \verb|A1.T| $=$ \verb|A2.T|, that would be
disaster!
\end{aside}

\begin{aside}
\textbf{Guru meditation.} Why can't the \verb|PkgKey| just record a
set of \verb|Module|s, e.g. \verb|PkgKey ::= SrcPkgKey { Module }|?  Consider:

\begin{verbatim}
package p (A) requires (H1, H2) where
    signature H1(T) where
        data T
    signature H2(T) where
        data T
    module A(A(..)) where
        import qualified H1
        import qualified H2
        data A = A H1.T H2.T

package q (A12, A21) where
    module I1(T) where
        data T = T Int
    module I2(T) where
        data T = T Bool
    include p (A as A12) requires (H1 as I1, H2 as I2)
    include p (A as A21) requires (H1 as I2, H2 as I1)
\end{verbatim}

The sets of modules provided for both includions of \verb|p| are the same,
but \verb|A12.A :: I1.T -> I2.T -> A12.A| while \verb|A21.A :: I2.T -> I1.T -> A12.A|.
\end{aside}

\newpage

\begin{aside}
\textbf{Guru meditation.} Why can't the required portion of a shape
refer to \verb|OccName|s instead of \verb|Name|s, e.g. \verb|"required:" { ModName "->" { OccName } }|?  Consider:

\begin{verbatim}
package p () requires (A, B) where
    signature A(T) where
        data T
    signature B(T) where
        import T
\end{verbatim}

This has the shape:

\begin{verbatim}
provided: (empty)
required:
    A -> { HOLE:A.T }
    B -> { HOLE:A.T }
\end{verbatim}

In particular, we conclude \verb|A.T| $=$ \verb|B.T|.
\end{aside}

\begin{aside}
\textbf{Guru meditation.} Why do \verb|Name|s matter for values?  Consider:

\begin{verbatim}
package p (A) requires (H1, H2) where
    signature H1(x) where
        x :: Int
    signature H2(x) where
        import H1(x)
    module A(y) where
        import H1
        import H2
        y = x
\end{verbatim}

The reference to \verb|x| in \verb|A| is unambiguous, because it is known
that \verb|x| from \verb|H1| and \verb|x| from \verb|H2| are the same (have
the same \verb|Name|.)  If this was not known, it would be ambiguous and
cause an error.
\end{aside}

\section{How to shape}

\emph{You might consider skipping this section and reading some of the
examples, before coming back.}

Here is the core Backpack language (minus some syntactic sugar and
ascription.)

\begin{verbatim}
package ::= "package" pkgname [pkgexports] "where" pkgbody
pkgbody ::= "{" pkgdecl_0 ";" ... ";" pkgdecl_n "}"
pkgdecl ::= "module"    modid [exports] "where" body
          | "signature" modid [exports] "where" body
          | "include"   pkgname [inclspec]
inclspec ::= "(" renaming_0 "," ... "," renaming_n [","] ")" -- (provides list)
             [ "requires" "(" renaming_0 "," ... "," renaming_n [","] ")" ]
pkgexports ::= inclspec
renaming ::= modid [ "as" modid ]
\end{verbatim}

Shaping proceeds in a few steps:

\paragraph{Pre-shaping}  Pre-shaping recursively calculates the provided
and required module names of packages.  Equivalently, it elaborates
package declarations and includes so that \verb|pkgexports| and
\verb|inclspec| are specified explicitly.

The pre-shape of a package is calculated by processing declarations in
order, calculating a set of provided module names $P$ (modules we are
planning to expose outside the package), available module names $A$
(modules which can be imported and fill requirements) and required
module names $R$ (requirements that must be filled by a user of the
package).  Then, absent a \verb|pkgexports|, the shape of the package is
(provides: $P$, requires: $R$).

\paragraph{Module} Given ``\verb|module M|'': let $P' = P \cup \{M\}$, $A' = A \cup \{M\}$ and $R' = R - \{M\}$. A module definition is both provided and available, and fills any requirement with the same name.

\paragraph{Signature} Given ``\verb|signature S|'': let $R' = R \cup \{S\}$ if $S \notin A$, and no change otherwise. A signature definition creates a requirement if there is not already another definition available.  This definition could be another signature, in which case $S \in R$ already!

\paragraph{Include}

Let the pre-shape of the included package be (provides: $P_I$, requires: $R_I$). \\
Given ``\verb|include pkgname (X0 as X'0, ..., Xn as X'n) requires (Y0 as Y'0, ..., Yn as Yn')|'':

\begin{itemize}
    \item Fail if \verb|X0, ..., Xn| $\nsubseteq P_I$
    \item Fail if \verb|Y0, ..., Yn| $\nsubseteq R_I$
    \item Let $A' = A \cup \{$ \verb|X'0, ..., X'n| $\}$
    \item Let $R_0 = $
    \item Let $R' = R - \{$ \verb|X'0, ..., X'n| $\} + \{$ \verb|Y'0, ..., Y'n| $\}$
    \item Add \verb|InclRequires| minus \verb|Y0, ..., Yn| to $R$, for all not in $A$
\end{itemize}

If you have a sole \verb|Xi| in any renaming list, it is sugar for \verb|Xi as Xi|. When an
\verb|inclspec| is absent, let the \verb|inclspec| be $P_I$ \verb|requires| $R_I$.

\section{Definite packages are simple}

When there aren't any signatures, package shapes are simple:
given an identifier named \verb|T| declared in a module \verb|A| in a package \verb|p|,
the module \verb|A| provides the name \verb|p():A.T|.  Thus

\begin{verbatim}
package p (A) where
    module A(T,x) where
        data T = T
        x = False
\end{verbatim}

has the shape

\begin{verbatim}
provides:
    A -> { p():A.T, p():A.x }
requires:
    (nothing)
\end{verbatim}

\paragraph{Reexports}  The Haskell source-language supports reexports.
In such a case, the shape of the module reports the \emph{original}
name.

\begin{verbatim}
package p(A,B) where
    module A(T) where
        data T = T
    module B(T) where
        import A
\end{verbatim}

has shape

\begin{verbatim}
provides:
    A -> { p():A.T }
    B -> { p():A.T } -- not p():B.T!
requires:
    (nothing)
\end{verbatim}

Haskell does not support changing the \verb|OccName| upon reexport;
the usual way of renaming types and values results in a new \verb|Name|.

\begin{verbatim}
package p (A,B) where
    module A(T, x) where
        data T = T
        x = True
    module B(S, y) where
        import A
        type S = T
        y = x
\end{verbatim}

has shape

\begin{verbatim}
provides:
    A -> { p():A.T, p():A.x }
    B -> { p():B.S, p():B.y } -- not p():A.T, p():A.x!
requires:
    (nothing)
\end{verbatim}

\begin{aside}
\textbf{Guru meditation.}  If we can change \verb|OccName|s on reexport,
we need a different definition of shape:
\begin{verbatim}
Shape ::=
    "provided:" ModName "->" { OccName ":" Name }
    "required:" ModName "->" { OccName ":" Name }
\end{verbatim}

Without \verb|OccName| renaming, the \verb|OccName| always equals
the \verb|OccName| of the \verb|Name|.
\end{aside}

\section{Signatures in indefinite packages}

If there is a signatures, we say its identifiers are from the special
\verb|HOLE| package.  (These are a bit like skolem variables.)
Signatures add to the requirement of a module shape
in addition to the provides.

\begin{verbatim}
package p-sig (A) requires (A) where
    signature A(T,x) where
        data T
        x :: Bool
\end{verbatim}

has shape

\begin{verbatim}
provides:
    A -> { HOLE:A.T, HOLE:A.x }
requires:
    A -> { HOLE:A.T, HOLE:A.x }
\end{verbatim}

\paragraph{No export}  You don't have to export a signature,
but you must require it.  In that case, it is required but
not provided.

\begin{verbatim}
package p-sig (B) requires (A,B) where
    signature A(T) where
        data T
    signature B(S) where
        import A
        data S = S T
\end{verbatim}

has shape

\begin{verbatim}
provides:
    B -> { HOLE:B.S }
requires:
    A -> { HOLE:A.T }
    B -> { HOLE:B.S }
\end{verbatim}

\paragraph{Reexports}  Signatures also support reexports. They
work in the same way as in modules.

\begin{verbatim}
package p (A,B) where
    signature A(T) where
        data T = T
    signature B(T) where
        import A
\end{verbatim}

has shape

\begin{verbatim}
provides:
    A -> { HOLE:A.T }
    B -> { HOLE:A.T }
requires:
    A -> { HOLE:A.T }
    B -> { HOLE:A.T }
\end{verbatim}

Signatures can import modules too!

\section{Modules in indefinite packages}

When you define a module in a package with holes, when constructing
the package key for names defined in this module, you must also specify
how the holes in the package are filled in.  For example:

\begin{verbatim}
package p (A) requires (H) where
    signature H where
        x :: Bool
    module A where
        import H
        y = x
\end{verbatim}

has shape

\begin{verbatim}
provides:
    A -> { p(H -> HOLE:H):A.y } -- not p():A.y!
requires:
    H -> { HOLE:H.x }
\end{verbatim}

The mapping \verb|H -> HOLE:H| says that \verb|p| was instantiated with

\section{Includes}

An include brings the shape of the package included into the context
of our package:

\begin{verbatim}
package p (A) where
    module A(x) where
        x = True

package q (A, B) where
    include A
    module B(y) where
        y = True
\end{verbatim}

\verb|p| provides \verb|A -> { p:A.x }|, while \verb|q| has shape:

\begin{verbatim}
provides:
    A -> { p:A.x }
    B -> { q:B.y }
requires:
    (nothing)
\end{verbatim}

If none of the module names from the included package and the
current package overlap, things are simple. Things are more
complex when there are overlapping names: in this case, \emph{linking}
should occur.

\paragraph{Renaming holes}

If you rename a hole, the occurrences of \verb|HOLE:A| in modules and names
are renamed:

\begin{verbatim}
package p (M) requires (A) where
    signature A(x) where
        x :: Bool
    module M(y) where
        import A
        y = x

package q (M) requires (B) where
    include A (M) requires (A as B)
\end{verbatim}

has shapes:

\begin{verbatim}
p provides:
    M -> { p(A -> HOLE:A):M.y }
p requires:
    A -> { HOLE:A.x }

q provides:
    M -> { p(A -> HOLE:B):M.y }
q requires:
    B -> { HOLE:B.x }
\end{verbatim}

\paragraph{Linking a signature with an implementation}

If you fill a hole with an implementation, the occurrences of the hole's \verb|Module|, e.g. \verb|HOLE:A|, are replaced with the implementation module identity, and the
occurences of the hole's \verb|Name|s, e.g. \verb|HOLE:A.x|, are replaced with
the implementation's matching \verb|Name| (e.g., having the same \verb|OccName|).
These are two separate substitutions!

\begin{verbatim}
package p (B) requires (A) where
    signature A(T) where
        data T
    module B(T, x) where
        import A(T)
        x :: Bool

package q (A, B) where
    module A(T) where
        data T = T
    include p
\end{verbatim}

has shapes:

\begin{verbatim}
p provides:
    B -> { HOLE:A.T, p(A -> HOLE:A):B.x }
p requires:
    A -> { HOLE:A.T }

q provides:
    B -> { q():A.T, p(A -> q():A):B.x }
    A -> { q():A.T }
q requires:
    (nothing)
\end{verbatim}

Note that I can also include first and then define the module; the
result is the same.

\begin{aside}
\textbf{Guru meditation.}  Why can't we just replace all occurrences of
\verb|HOLE:A| with \verb|q():A|?  A modified \verb|package q|:

\begin{verbatim}
package q (TyA, A, B) where
    module TyA(T) where
        data T = T
    module A(T) where
        import TyA(T)
    include p
\end{verbatim}

should have shape:

\begin{verbatim}
q provides:
    TyA -> { q():TyA.T }
    A   -> { q():TyA.T }
    B   -> { q():TyA.T, p(A -> q():A):B.x }     -- NB: not p(A -> q():TyA)
q requires:
    (nothing)
\end{verbatim}

\verb|HOLE:A.T| is substituted with \verb|q():TyA.T|, but \verb|HOLE:A| is
substituted with \verb|q():A|!
\end{aside}

\paragraph{Linking a signature with a signature}

\begin{verbatim}
package p requires (H) where
    include base
    signature H(Int) where
        import Prelude

package q requires (H) where
    include base
\end{verbatim}

\end{document}
